package polytech.tours.di.parallel.tsp;

import java.util.Collections;
import java.util.Properties;
import java.util.concurrent.Callable;

import polytech.tours.di.parallel.tsp.Instance;
import polytech.tours.di.parallel.tsp.Solution;

/**
 * TSPComputation.java
 * Purpose : Implementation of parallel tasks to search the shortest way
 * 
 * @author Pierrick Bobet, Remy Bouteloup
 * @version 1.0 17/04/12
 */
public class TSPComputation implements Callable<Solution> {

  /**
   * Store current instance
   */
  private Instance instance;
  
  /**
   * Store config file
   */
  private Properties config;
  
  /**
   * Constructor per default
   * @param instance
   */
  public TSPComputation(Instance instance, Properties config) {
    this.instance = instance;
    this.config = config;
  }

  /**
   * Redifinition of call method
   */
  public Solution call() throws Exception {
	  // Generate random solution and set to null two others
	  Solution bestSolution = generateRamdom(), tempSolution = null, localSearchSolution = null;
	  
	  // Recover max time of treatment
	  long max_cpu=Long.valueOf(config.getProperty("maxcpu"));
	  
	  // Set an integer to count the number of localSearch.
	  int counter = 0;
	  
	  // Start counter
	  long startTime=System.currentTimeMillis();
	  
	  // Main loop to search the shortest way
	  while((System.currentTimeMillis()-startTime)/1_000<=max_cpu) {
		  counter++;
		  
		  // Set a random solution named tempSolution
	      tempSolution = generateRamdom();
	      
	      // Run a localSearch on this tempSolution to find the optimum local
	      localSearchSolution = localSearch(tempSolution, startTime);
	     
	      // If the optimum local founded is lower than the current best solution named bestSolution
	      if(localSearchSolution.getOF() < bestSolution.getOF())
	    	  bestSolution = localSearchSolution;
	  }
	  // Set the counter on the solution returned
	  bestSolution.setCountNbOptimLocal(counter);
	  return bestSolution;
  }

  /**
   * Search the optimum local of one temp solution
   * @param tempSolution
   * @return Solution The best solution founded
   */
  private Solution localSearch(Solution tempSolution, long startTime) {
	  // A boolean to stop the loop if the solution retuned by exploreNeighborhood is too bad
	  boolean bestIsFound = true;
	  
	  // A solution to store the result returned by exploreNeighborhood
	  Solution bestNeighborhood = null;
	  
	  while(bestIsFound && (System.currentTimeMillis()-startTime)/1_000<=Long.valueOf(config.getProperty("maxcpu"))) {
		  // Send the tempSolution, generated by call solution.
		  bestNeighborhood = exploreNeighborhood(tempSolution);
      
		  // If the path is better
		  if(bestNeighborhood.getOF() < tempSolution.getOF())
			  tempSolution = bestNeighborhood;
		  else
			  bestIsFound = false;
	  }
	  return tempSolution;
  }

  /**
   * Explore the neighborhood to find the best solution 
   * @param tempSolution
   * @return Solution The best solution founded
   */
  private Solution exploreNeighborhood(Solution tempSolution) {
	// Solutions to store temporary solution
    Solution bestNeighborhood = tempSolution.clone();
    Solution bestTempSolution = tempSolution.clone();
    
    // Swap city to determine the shortest path
    for(int i = 0 ; i < instance.getN() ; i++)
      for(int j = 0 ; j < instance.getN() ; j++) {
        bestNeighborhood.swap(i, j);
        
        // Computation of the solution
        bestNeighborhood.setOF(TSPCostCalculator.calcOF(instance, bestNeighborhood));
        
        // If the path founded is shortest
        if(bestNeighborhood.getOF() < tempSolution.getOF())
          bestTempSolution = bestNeighborhood.clone();
      }
    return bestTempSolution;
  }

  /**
   * Generate a random solution
   * @return Solution The random solution created
   */
  private Solution generateRamdom() {
    Solution randomSolution = new Solution();
    
    // Add numbers 0 until the number of cities in the new solution
    for (int i = 0; i < instance.getN(); i++)
      randomSolution.add(i);
    
    // Shuffle the previously filled table
    Collections.shuffle(randomSolution);
    
    // Computation of the solution
    randomSolution.setOF(TSPCostCalculator.calcOF(instance, randomSolution));
    return randomSolution;
  }
}